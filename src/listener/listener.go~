package listener

import (
	"bufio"
	"fmt"
	"net"
	"os"

	"message"
)

const BATCHSIZE int = 10

type Listener struct {
	clientMessages    chan message.Message
	preacceptMessages chan message.Message
	acceptMessages    chan message.Message
	commitMessages    chan message.Message
	okMessages        chan message.Message
	adminMessages     chan message.Message
	ln                net.Listener
}

func NewListener(ln net.Listener) *Listener {
	l := new(Listener)
	l.clientMessages = make(chan message.Message)
	l.preacceptMessages = make(chan message.Message)
	l.acceptMessages = make(chan message.Message)
	l.commitMessages = make(chan message.Message)
	l.okMessages = make(chan message.Message)
	l.adminMessages = make(chan message.Message)
	l.ln = ln
	return l
}

func batch(ch chan message.Message, m1 message.Message) []message.Message {
	end := false
	messages := make([]message.Message, BATCHSIZE)
	messages[0] = m1
	i := 1
	for ; i < BATCHSIZE && !end; i++ {
		select {
		case m := <-ch:
			messages[i] = m
		default:
			end = true
		}
	}
	return messages[:i-1]
}

func (l *Listener) Get() []message.Message {
	var msg []message.Message
	select {
	case m := <-l.adminMessages:
		msg = batch(l.adminMessages, m)
	case m := <-l.okMessages:
		msg = batch(l.okMessages, m)
	case m := <-l.commitMessages:
		msg = batch(l.commitMessages, m)
	case m := <-l.acceptMessages:
		msg = batch(l.acceptMessages, m)
	case m := <-l.preacceptMessages:
		msg = batch(l.preacceptMessages, m)
	case m := <-l.clientMessages:
		msg = batch(l.clientMessages, m)
	}
	return msg
}

func (l *Listener) handleConnection(conn net.Conn) {
	m := &message.Message{}
	buffered := bufio.NewReader(conn)
	for {
		err := m.Unmarshal(buffered)
		if err != nil {
			fmt.Println("Read error: ", err)
			return
		}
		switch m.T {
		case message.REQUEST:
			l.clientMessages <- *m
		case message.CONNECT:
			l.adminMessages <- *m
		case message.HOSTLIST:
			l.adminMessages <- *m
		case message.ADDHOST:
			l.adminMessages <- *m
		case message.PREACCEPT:
			l.preacceptMessages <- *m
		case message.PREACCEPTOK:
			l.okMessages <- *m
		case message.ACCEPT:
			l.acceptMessages <- *m
		case message.ACCEPTOK:
			l.okMessages <- *m
		case message.COMMIT:
			l.commitMessages <- *m
		}
	}
}

func (l *Listener) Listen() {
	for {
		conn, err := l.ln.Accept()
		if err != nil {
			fmt.Fprintln(os.Stderr, "Bad connection.")
			continue
		}
		go l.handleConnection(conn)
	}
}
